<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Line Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        .pages {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        #home {
            width: 100vw;
        }
        #game_map_container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .cell-0 { background-color: gray; }
        .cell-1 { background-color: white; }
        .cell-2 { background-color: green; }
        .cell-3 { background-color: rgb(0, 136, 255); }
        .cell-4 { background-color: rgb(255, 119, 0); }
        .visited { background-color: green; }

        #end_game {
            display: none;
        }
        #leave_game {
            display: flex;
        }
        .game_btn {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #game_title {
            margin-bottom: 20px;
            text-align: center;
        }
        button {
    margin: 10px;
    padding: 10px 20px;
    font-size: 16px;
    background-color: #fdf298;
    border-radius: 10px;
    border-color: #d9a100;
}

.setting {
    display: flex;
    width: 80%;
    max-width: 424px;
    margin-bottom: 20px;
    padding: 20px;
    border: 3px dotted #d9a100;
    border-radius: 20px;
    background-color: #fdf298;
    flex-direction: column;
    align-items: center;
}
.select_item {
    /* width: 100%; */
    display: flex;
    margin: 0 10px;
    align-items: center;
}
select {
    margin-left: 10px;
    padding: 4px;
    background-color: transparent;
    border-radius: 10px;
}
select:focus {
    outline: none;
}
    </style>
</head>
<body>
    <div class="pages" id="home">
        <h1 id="home_title">
            One Line Game <br>
            ver: ALPHA 0.1
        </h1>
        <p>WARNING: Extra maps were generated by artificial intelligence tool, may including error, sometimes you cannot finish them</p>
        <p>WARNING: Alpha version is not a stable release, may including errors and bugs</p>
        <div class="setting">
            <div class="select_item">
                <label for="select_map">select map</label>
                <select id="select_map" onchange="gameInfo.selected_map = this.value; update_map_state();">

                </select>
            </div>
            
        </div>
        <button onclick="open_game()">Start Game</button>
        <!-- <button onclick="open_map_preview()">map_preview_dev</button> -->
    </div>

    <div class="pages" id="game">
        <h1 id="game_title">GAME</h1>
        <div id="game_map_container"></div>
        <button id="end_game" class="game_btn" onclick="init()">END GAME</button>
        <button id="leave_game" class="game_btn" onclick="init()">LEAVE GAME</button>
    </div>

    <div class="pages" id="end">

    </div>
    <script>
        
        const pages = document.querySelectorAll('.pages');
        const game_title = document.getElementById('game_title');
        const timer = {
            count: 0,
            start: function() {
                this.count = 0;
                this.interval = setInterval(() => {
                    this.count++;
                    // console.log("Timer:", this.count);
                }, 100);
            },
            stop: function() {
                clearInterval(this.interval);
            },
            reset: function() {
                this.count = 0;
            }
        }

        // mapè§„åˆ™ï¼š
        // 0 - ä¸å¯ç”¨
        // 1 - å¯è¿çº¿
        // 2 - èµ·ç‚¹
        // 3 - ç»ˆç‚¹

        var maps = [
            {
                name: "default map 1",
                data: [
                    [0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0],
                    [0, 1, 0, 1, 0],
                    [0, 1, 2, 3, 0],
                    [0, 0, 0, 0, 0]
                ]
            },
            {
                name: "default map 2",
                data: [
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 2, 1, 1, 1, 1, 0],
                    [0, 0, 3, 1, 1, 1, 0],
                    [0, 0, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0]
                ]
            }
        ];
        var gameInfo = {
            selected_map: 0,
            // current_hover_cell: {x: null, y: null},
            current_available_moves: [],
            start_pos: null,
            end_pos: null
            
        }

        async function loadSequentialData(baseUrl = './productData') {
		    var result = [];
		
		    try {
		        const mainResponse = await fetch(`${baseUrl}/main.json`);
		        if (!mainResponse.ok) {
		            throw new Error(`cannot load main.json: HTTP ${mainResponse.status}`);
		        }
		
		        const mainData = await mainResponse.json();
		        const fileList = mainData.files || [];
		
		        if (fileList.length === 0) {
		            throw new Error('main.json does not have a list in it');
		        }
		
		        console.log(`${fileList.length} files in list`, fileList);
		
		        for (const filename of fileList) {
		            try {
		                const response = await fetch(`${baseUrl}/${filename}`);
		                if (!response.ok) {
		                    throw new Error(`load failed: ${filename}, HTTP ${response.status}`);
		                }
		
		                const data = await response.json();
		                result.push(data);
		            } catch (fileError) {
		                console.warn(`skip ${filename}:`, fileError);
		            }
		        }
		        return result;
		
		    } catch (error) {
		        console.error(error);
		        return [];
		    }
		}

        var event_listener_hendler = e => e.preventDefault();

        const user_clicks = {
            disable: function() {
                console.log("ç”¨æˆ·ç‚¹å‡»å·²ç¦ç”¨");
                // ç»‘å®šäº‹ä»¶ pc
                document.addEventListener('mousedown', startPress);
                document.addEventListener('mouseup', endPress);
                document.addEventListener('mousemove', movePress);
                // ç»‘å®šäº‹ä»¶ mobile
                document.addEventListener('touchstart', startPress, { passive: false });
                document.addEventListener('touchend', endPress);
                document.addEventListener('touchmove', movePress, { passive: false });

                document.addEventListener('dragstart', event_listener_hendler);
                document.addEventListener('mousedown', event_listener_hendler);
            },
            enable: function () {
                console.log("ç”¨æˆ·ç‚¹å‡»å·²å¯ç”¨");
                // è§£ç»‘äº‹ä»¶ pc
                document.removeEventListener('mousedown', startPress);
                document.removeEventListener('mouseup', endPress);
                document.removeEventListener('mousemove', movePress);
                // è§£ç»‘äº‹ä»¶ mobile
                document.removeEventListener('touchstart', startPress);
                document.removeEventListener('touchend', endPress);
                document.removeEventListener('touchmove', movePress);

                // event_listener_hendler = e => e.preventDefault();
                document.removeEventListener('dragstart', event_listener_hendler);
                document.removeEventListener('mousedown', event_listener_hendler);
        }
        }

        let isHolding = false;
        let holdTimer = null;

        let current_hover_cell = { x: null, y: null };
        const HOLD_THRESHOLD = 150;

        // å·¥å…·å‡½æ•°ï¼šä»äº‹ä»¶ä¸­è·å–è§¦ç‚¹ä¸‹çš„å…ƒç´ 
        function getEventTarget(e) {
            if (e.touches && e.touches.length > 0) {
                return document.elementFromPoint(
                    e.touches[0].clientX,
                    e.touches[0].clientY
                );
            }
            return e.target;
        }

        // å¤„ç†æ ¼å­ï¼ˆé¿å…é‡å¤ï¼‰
        function handleCell(cell) {
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);

            if (x != current_hover_cell.x || y != current_hover_cell.y) {
                current_hover_cell = { x, y };
                console.log("æ‚¬æµ®åˆ°æ–°æ ¼å­:", current_hover_cell, state[y][x], cell);
                update_cell(cell);
            }
        }

        // æŒ‰ä¸‹å¼€å§‹
        function startPress(e) {
            if (e.button !== undefined && e.button !== 0) return;

            const startTarget = getEventTarget(e);

            holdTimer = setTimeout(() => {
                isHolding = true;
                console.log("é•¿æŒ‰å¼€å§‹");

                // é•¿æŒ‰åç«‹å³å¤„ç†å½“å‰æ ¼å­
                const cell = startTarget.closest('.cell');
                if (cell) {
                    handleCell(cell);
                }

            }, HOLD_THRESHOLD);
        }

// æŒ‰ä¸‹ç»“æŸ
        function endPress() {
            clearTimeout(holdTimer);
            if (isHolding) {
                console.log("é•¿æŒ‰ç»“æŸ");
                let end = gameInfo.end_pos;
                if (!state[end.y][end.x].visited) {
                    reset_game_state();
                    // user_clicks.enable();
                }
            }
            isHolding = false;
        }

        // ç§»åŠ¨æ—¶å¤„ç†
        function movePress(e) {
            if (!isHolding) return;

            const target = getEventTarget(e);
            const cell = target.closest('.cell');
            if (cell) {
                handleCell(cell);
            }
        }

        var state = '';
        function update_map_state() {
            console.log("æ›´æ–°åœ°å›¾çŠ¶æ€ï¼Œé€‰æ‹©çš„åœ°å›¾ï¼š", {
                map_resource: maps[parseInt(gameInfo.selected_map)],
                map_index: parseInt(gameInfo.selected_map)
            });
            state = maps[parseInt(gameInfo.selected_map)].data.map(row => row.map((type) => ({
                visited: false,
                is_path: type === 1,
                is_end: type === 3,
                is_start: type === 2,
                is_wall: type === 0,
                        }
                    )
                )
            );
            gameInfo.start_pos = null;
            gameInfo.end_pos = null;
            gameInfo.current_available_moves = [];
        };

        function generate_map(){
            update_map_state();
            const map_container = document.getElementById('game_map_container');
            map_container.innerHTML = ''; // Clear previous map if any

            const map_data = maps[gameInfo.selected_map].data;
            let map_html = '';
            for(let i = 0; i < map_data.length; i++) {
                map_html += '<div class="map-row" style="display: flex;">';
                for(let j = 0; j < map_data[i].length; j++) {
                    let in_cell_text = '';
                    if (state[i][j].is_start) {
                        gameInfo.start_pos = {x: j, y: i};
                        in_cell_text = 'ğŸš©';
                    } else if (state[i][j].is_end) {
                        gameInfo.end_pos = {x: j, y: i};
                        in_cell_text = 'ğŸ';
                    } else {
                        in_cell_text = '';
                    }

                    
                    map_html += `<div class="cell cell-${map_data[i][j]}" data-x="${j}" data-y="${i}">${in_cell_text}</div>`;
                }
                map_html += '</div>';
            }

            map_container.innerHTML = map_html;
        }

        function open_game(){
            showPage('game');
            generate_map(true);
            user_clicks.disable();
            timer.start();
        }

        /*
        *@param {Object} el - html element
        */
        function update_cell(el) {
            const x = parseInt(el.dataset.x);
            const y = parseInt(el.dataset.y);
            const a = gameInfo.start_pos;
            const b = gameInfo.end_pos;

            if (state[y][x].is_wall) {
                console.log("ä¸å¯é€šè¡Œçš„æ ¼å­");
                return;
            }

            if (!state[a.y][a.x].visited && !state[y][x].is_start) {
                show_notification("è¯·ä»èµ·ç‚¹å¼€å§‹è¿çº¿ï¼");
                return;
            } else if (state[y][x].is_start && state[a.y][a.x].visited) {
                console.log("å·²ç»ä»èµ·ç‚¹å¼€å§‹è¿çº¿äº†ï¼");
                return;
            } else if (state[y][x].is_start && !state[a.y][a.x].visited) {
                // ä»èµ·ç‚¹å¼€å§‹ no need to check available moves
                state[y][x].visited = true;
                el.classList.add('visited');
                set_new_available_moves(y, x);
            }

            if (!state[y][x].visited && is_avaliable_move(y, x)) {
                state[y][x].visited = true;
                el.classList.add('visited');
                set_new_available_moves(y, x);
            } else {
                console.log("ä¸å¯ç”¨çš„ç§»åŠ¨");
                return;
            }

            if (state[y][x].is_end && state[y][x].visited) {
                console.log("åˆ°è¾¾ç»ˆç‚¹");
                if (is_all_cells_visited()) {
                    console.log("æ‰€æœ‰æ ¼å­å‡å·²è®¿é—®ï¼Œæ¸¸æˆèƒœåˆ©ï¼");
                    user_clicks.enable();
                    timer.stop();
                    game_title.innerHTML = `WIN! <br/> Time: ${(timer.count / 10).toFixed(1)}s`;
                    document.getElementById('leave_game').style.display = 'none';
                    document.getElementById('end_game').style.display = 'flex';

                } else {
                    console.log("è¿˜æœ‰æœªè®¿é—®çš„æ ¼å­");
                    game_title.innerText = "TRY AGAIN!";
                    reset_game_state();
                    setTimeout(() => {
                        reset_game_page();
                        
                    }, 1500);
                }

            }
            
            
        }
        function reset_game_page() {
            game_title.innerText = "One Line Game";
            document.getElementById('leave_game').style.display = 'flex';
            document.getElementById('end_game').style.display = 'none';
        }
        // ä¼ å…¥å½“å‰çš„x, yï¼Œè®¾ç½®æ–°çš„å¯ç”¨ç§»åŠ¨
        function set_new_available_moves(y, x) {
            y = parseInt(y);
            x = parseInt(x);
            gameInfo.current_available_moves = [];
            let avalible_moves = [];
            if (!state[y-1][x].is_wall) avalible_moves.push({x: x, y: y-1});
            if (!state[y+1][x].is_wall) avalible_moves.push({x: x, y: y+1});
            if (!state[y][x-1].is_wall) avalible_moves.push({x: x-1, y: y});
            if (!state[y][x+1].is_wall) avalible_moves.push({x: x+1, y: y});
            gameInfo.current_available_moves = avalible_moves;
        }
        function is_avaliable_move(y, x) {
            x = parseInt(x);
            y = parseInt(y);
            for (let i = 0; i < gameInfo.current_available_moves.length; i++) {
                if (gameInfo.current_available_moves[i].x == x && gameInfo.current_available_moves[i].y == y) {
                    return true;
                }
            }
            return false;
        }

        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰éwallæ ¼å­éƒ½è¢«è®¿é—®
        function is_all_cells_visited() {
            for (row of state) {
                for (const cells of row) {
                    if (!cells.is_wall && !cells.visited) {
                        return false;
                    }
                }
            }
            return true;
        }

        function reset_game_state() {
            for (let i = 0; i < state.length; i++) {
                for (let j = 0; j < state[i].length; j++) {
                    state[i][j].visited = false;
                }
            }
            generate_map();
        }

        //ç”¨äºä»£æ›¿alertçš„é€šçŸ¥åŠŸèƒ½
        function show_notification(message) {
            console.log("é€šçŸ¥ï¼š", message);
        }

        function showPage(id) {
            pages.forEach(page => {
                page.style.display = (page.id === id) ? 'flex' : 'none';
            });
        }
        function load_selection(){
            const select_map = document.getElementById('select_map');
            let select_map_list = '';

            
            // console.log("åŠ è½½çš„åœ°å›¾æ•°æ®ï¼š", maps);
            let loaded_data = maps;
            // loaded_data = ;

            for(let i = 0; i < loaded_data.length; i++) {
                select_map_list += `<option value="${i}">${loaded_data[i].name}</option>`;
            }
            select_map.innerHTML = select_map_list;
        }
        function init() {
            const home_title = document.getElementById('home_title');
            load_selection();
            timer.stop();
            timer.reset();
            update_map_state();
            showPage('home');
            user_clicks.enable();
            game_title.innerText = "One Line Game";
            document.getElementById('leave_game').style.display = 'flex';
            document.getElementById('end_game').style.display = 'none';

            gameInfo = {
                selected_map: 0,
                // current_hover_cell: {x: null, y: null},
                current_available_moves: [],
                start_pos: null,
                end_pos: null
            }
        };
        init();
        window.onload = async () => {
            const loaded_maps = await loadSequentialData('./maps');
            if (loaded_maps.length > 0) {
                maps = maps.concat(loaded_maps);
                console.log("extra maps loaded: ", maps);
                init();
            } else {
                console.log("no extra maps: ", maps);
            }
        };
    </script>
</body>
</html>